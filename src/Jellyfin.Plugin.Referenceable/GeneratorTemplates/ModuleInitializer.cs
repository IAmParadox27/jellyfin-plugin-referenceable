// <auto-generated />
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Loader;
using System.Collections.Generic;

using Microsoft.Extensions.DependencyInjection;

namespace {{namespace}}.Generated
{
#nullable enable
    public class ModuleInitializer
    {
        internal class EmbeddedAssemblyData
        {
            public Assembly ContainingAssembly { get; set; }
            public string ManifestResourceName { get; set; }
            public string FilePath { get; set; }
        }
        
        public static bool IsAvailable { get; set; } = false;
        
        private static Dictionary<string, EmbeddedAssemblyData> s_assemblyCache = new Dictionary<string, EmbeddedAssemblyData>();

        public static void RegisterAssembly(string assemblyName, Assembly assembly, string manifestResourceName)
        {
            if (s_assemblyCache.ContainsKey(assemblyName))
            {
                bool originalCollectible = AssemblyLoadContext.GetLoadContext(s_assemblyCache[assemblyName].ContainingAssembly).IsCollectible;
                bool newCollectible = AssemblyLoadContext.GetLoadContext(assembly).IsCollectible;

                if (!originalCollectible && newCollectible)
                {
                    s_assemblyCache[assemblyName].ContainingAssembly = assembly;
                    s_assemblyCache[assemblyName].ManifestResourceName = manifestResourceName;
                    s_assemblyCache[assemblyName].FilePath = assembly.Location;
                }
            }
            else if (assembly != null)
            {
                s_assemblyCache.Add(assemblyName, new EmbeddedAssemblyData
                {
                    ContainingAssembly = assembly,
                    ManifestResourceName = manifestResourceName,
                    FilePath = assembly.Location
                });
            }
        }
        
        [ModuleInitializer]
        public static void Init()
        {
            AssemblyLoadContext? loadContext = AssemblyLoadContext.GetLoadContext(typeof(ModuleInitializer).Assembly) as AssemblyLoadContext;

            if (loadContext != null && loadContext.IsCollectible)
            {
                // Reload ourselves in a referencable way.
                // First pass we're just going to load them all into the same assembly load context.
                // Its not collectible anyway.
                AssemblyLoadContext newLoadContext = AssemblyLoadContext.All.FirstOrDefault(x => x.Name == "Jellyfin.Plugin.Referenceable") ?? new AssemblyLoadContext("Jellyfin.Plugin.Referenceable");
                
                if (File.Exists(typeof(ModuleInitializer).Assembly.Location))
                {
                    newLoadContext.LoadFromAssemblyPath(typeof(ModuleInitializer).Assembly.Location);
                }
                else
                {
                    // This approach actually doesn't work, but this is here
                    // to remind me that I need to figure out some way of
                    // getting the bytes for all assemblies... somehow.
                    MethodInfo? methodGetRawBytes = Assembly.GetExecutingAssembly().GetType().GetMethod("GetRawBytes", BindingFlags.Instance | BindingFlags.NonPublic);
                    if (methodGetRawBytes != null)
                    {
                        byte[]? assemblyBytes = methodGetRawBytes.Invoke(null, null) as byte[];

                        if (assemblyBytes != null)
                        {
                            MemoryStream memoryStream = new MemoryStream(assemblyBytes);
                            memoryStream.Seek(0, SeekOrigin.Begin);

                            newLoadContext.LoadFromStream(memoryStream);
                        }
                    }
                }

                return;
            }

            AppDomain.CurrentDomain.AssemblyResolve += ResolveAssembly;
            
            IsAvailable = true;
        }
        
        public static bool IsInReferenceableContext<T>()
        {
            return !AssemblyLoadContext.GetLoadContext(typeof(T).Assembly).IsCollectible;
        }

        private static Assembly? ResolveAssembly(object? sender, ResolveEventArgs args)
        {
            AssemblyLoadContext thisLoadContext = AssemblyLoadContext.GetLoadContext(Assembly.GetExecutingAssembly())!;
            
            if (s_assemblyCache.ContainsKey(args.Name))
            {
                Stream? manifest = s_assemblyCache[args.Name].ContainingAssembly.GetManifestResourceStream(s_assemblyCache[args.Name].ManifestResourceName);
                return thisLoadContext.LoadFromStream(manifest);
            }
            
            return null;
        }

        public static dynamic? CreateReferenceableObject<T>(params object?[]? args)
        {
            return CreateReferenceableObject(typeof(T), args);
        }
        
        public static dynamic? CreateReferenceableObject(Type type, params object?[]? args)
        {
            AssemblyLoadContext? loadContext = AssemblyLoadContext.All.FirstOrDefault(x => x.Name == "Jellyfin.Plugin.Referenceable");

            if (loadContext == null)
            {
                throw new KeyNotFoundException(@"Could not find Jellyfin.Plugin.Referenceable as an AssemblyLoadContext");
            }
            
            Type? referenceableType = loadContext.Assemblies.SelectMany(x => x.GetTypes()).FirstOrDefault(x => x.FullName == type.FullName);

            if (referenceableType == null)
            {
                return null;
            }
            
            return Activator.CreateInstance(referenceableType, args);
        }

        public static dynamic? CreateReferenceableObject<T>(IServiceProvider serviceProvider, params object[]? args)
        {
            return CreateReferenceableObject(typeof(T), serviceProvider, args);
        }
        
        public static dynamic? CreateReferenceableObject(Type type, IServiceProvider serviceProvider, params object[]? args)
        {
            AssemblyLoadContext? loadContext = AssemblyLoadContext.All.FirstOrDefault(x => x.Name == "Jellyfin.Plugin.Referenceable");

            if (loadContext == null)
            {
                throw new KeyNotFoundException(@"Could not find Jellyfin.Plugin.Referenceable as an AssemblyLoadContext");
            }
            
            Type? referenceableType = loadContext.Assemblies.SelectMany(x => x.GetTypes()).FirstOrDefault(x => x.FullName == type.FullName);
            
            if (referenceableType == null)
            {
                return null;
            }

            if (args == null || args.Length == 0)
            {
                return ActivatorUtilities.CreateInstance(serviceProvider, referenceableType);
            }

            return ActivatorUtilities.CreateInstance(serviceProvider, referenceableType, args);
        }
    }
#nullable restore
}