// <auto-generated />
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Loader;
using System.Collections.Generic;
using System.Diagnostics; 
using Microsoft.Extensions.DependencyInjection;

namespace {{namespace}}.Generated
{
#nullable enable
    public class ModuleInitializer
    {
        internal class EmbeddedAssemblyData
        {
            public Assembly ContainingAssembly { get; set; }
            public string ManifestResourceName { get; set; }
            public string FilePath { get; set; }
        }
        
        public static bool IsAvailable { get; set; } = false;
        
        private static Dictionary<string, EmbeddedAssemblyData> s_assemblyCache = new Dictionary<string, EmbeddedAssemblyData>();

        public static void RegisterAssembly(string assemblyName, Assembly assembly, string manifestResourceName)
        {
            if (!IsAvailable)
            {
                Init();
            }

            if (AssemblyLoadContext.GetLoadContext(Assembly.GetExecutingAssembly()).IsCollectible)
            {
                AssemblyLoadContext nonCollectibleContext = AssemblyLoadContext.All.FirstOrDefault(x =>
                    x.Name == typeof(ModuleInitializer).Assembly.FullName && !x.IsCollectible);

                Type thisType = nonCollectibleContext.Assemblies.SelectMany(x => x.GetTypes())
                    .FirstOrDefault(x => x.Name == nameof(ModuleInitializer));

                MethodInfo thisMethod = thisType.GetMethod(nameof(RegisterAssembly), BindingFlags.Static | BindingFlags.Public);
                thisMethod.Invoke(null, new object[] { assemblyName, assembly, manifestResourceName });
                
                return;
            }
            
            if (s_assemblyCache.ContainsKey(assemblyName))
            {
                bool originalCollectible = AssemblyLoadContext.GetLoadContext(s_assemblyCache[assemblyName].ContainingAssembly).IsCollectible;
                bool newCollectible = AssemblyLoadContext.GetLoadContext(assembly).IsCollectible;

                if (!originalCollectible && newCollectible)
                {
                    s_assemblyCache[assemblyName].ContainingAssembly = assembly;
                    s_assemblyCache[assemblyName].ManifestResourceName = manifestResourceName;
                    s_assemblyCache[assemblyName].FilePath = assembly.Location;
                }
            }
            else if (assembly != null)
            {
                s_assemblyCache.Add(assemblyName, new EmbeddedAssemblyData
                {
                    ContainingAssembly = assembly,
                    ManifestResourceName = manifestResourceName,
                    FilePath = assembly.Location
                });
            }
        }
        
        [ModuleInitializer]
        public static void Init()
        {
            AssemblyLoadContext? loadContext = AssemblyLoadContext.GetLoadContext(typeof({{namespace}}.Generated.ModuleInitializer).Assembly) as AssemblyLoadContext;

            if (loadContext != null && loadContext.IsCollectible)
            {
                // Reload ourselves in a referencable way.
                // First pass we're just going to load them all into the same assembly load context.
                // Its not collectible anyway.
                AssemblyLoadContext newLoadContext = AssemblyLoadContext.All.FirstOrDefault(x => x.Name == "Jellyfin.Plugin.Referenceable") ?? new AssemblyLoadContext("Jellyfin.Plugin.Referenceable");
                
                if (File.Exists(typeof(ModuleInitializer).Assembly.Location))
                {
                    newLoadContext.LoadFromAssemblyPath(typeof(ModuleInitializer).Assembly.Location);
                }
                else
                {
                    // This approach actually doesn't work, but this is here
                    // to remind me that I need to figure out some way of
                    // getting the bytes for all assemblies... somehow.
                    MethodInfo? methodGetRawBytes = Assembly.GetExecutingAssembly().GetType().GetMethod("GetRawBytes", BindingFlags.Instance | BindingFlags.NonPublic);
                    if (methodGetRawBytes != null)
                    {
                        byte[]? assemblyBytes = methodGetRawBytes.Invoke(null, null) as byte[];

                        if (assemblyBytes != null)
                        {
                            MemoryStream memoryStream = new MemoryStream(assemblyBytes);
                            memoryStream.Seek(0, SeekOrigin.Begin);

                            newLoadContext.LoadFromStream(memoryStream);
                        }
                    }
                }

                return;
            }

            AppDomain.CurrentDomain.AssemblyResolve += ResolveAssembly;
            
            IsAvailable = true;

            List<Assembly> autoLoadedAssemblies = new List<Assembly>();
            RegisterEmbeddedAssemblies(Assembly.GetExecutingAssembly(), loadContext, autoLoadedAssemblies);

            // We cannot necessarily use the ModuleInitializer attribute for all libs, mainly Jellyfin.Plugin.Referenceable
            // because its also an analyzer, so we give the dev an opportunity to invoke it another way by naming their function
            // "ModuleInitializer" instead.
            var moduleInitializers = autoLoadedAssemblies.SelectMany(x => x.GetTypes())
                .SelectMany(x => x.GetMethods(BindingFlags.Static | BindingFlags.Public))
                .Where(x => x.Name == "ModuleInitializer" || x.GetCustomAttribute<ModuleInitializerAttribute>() != null);

            foreach (var moduleInitializer in moduleInitializers)
            {
                moduleInitializer.Invoke(null, new object[] { });
            }
        }

        private static void RegisterEmbeddedAssemblies(Assembly assembly, AssemblyLoadContext assemblyLoadContext, List<Assembly> outAutoLoadedAssemblies)
        {
            string[] embeddedDlls = assembly.GetManifestResourceNames().Where(x => x.EndsWith(".dll")).ToArray();

            foreach (string embeddedDll in embeddedDlls)
            {
                using var assemblyStream = assembly.GetManifestResourceStream(embeddedDll);
                using MemoryStream memoryStream = new MemoryStream();
                assemblyStream.CopyTo(memoryStream);
                
                string tmpDllLocation = $"{Path.GetTempFileName()}.dll";
                
                File.WriteAllBytes(tmpDllLocation, memoryStream.ToArray());
                
                AssemblyName assemblyName = AssemblyName.GetAssemblyName(tmpDllLocation);
                
                Console.WriteLine($"Registering assembly {assemblyName.FullName}");
                RegisterAssembly(assemblyName.FullName, assembly, embeddedDll);
                
                File.Delete(tmpDllLocation);
                
                Console.WriteLine($"Attempt to auto load assembly {assemblyName.FullName}");
                Assembly loadedAssembly = assemblyLoadContext.LoadFromAssemblyName(assemblyName);

                outAutoLoadedAssemblies.Add(loadedAssembly);
                
                RegisterEmbeddedAssemblies(loadedAssembly, assemblyLoadContext, outAutoLoadedAssemblies);
            }
        }
        
        public static bool IsInReferenceableContext<T>()
        {
            return !AssemblyLoadContext.GetLoadContext(typeof(T).Assembly).IsCollectible;
        }

        private static Assembly? ResolveAssembly(object? sender, ResolveEventArgs args)
        {
            Console.WriteLine($"Attempting to resolve assembly with name '{args.Name}'");
            
            AssemblyLoadContext thisLoadContext = AssemblyLoadContext.GetLoadContext(Assembly.GetExecutingAssembly())!;
            
            if (s_assemblyCache.ContainsKey(args.Name))
            {
                Stream? manifest = s_assemblyCache[args.Name].ContainingAssembly.GetManifestResourceStream(s_assemblyCache[args.Name].ManifestResourceName);
                return thisLoadContext.LoadFromStream(manifest);
            }
            
            return null;
        }

        public static dynamic? CreateReferenceableObject<T>(params object?[]? args)
        {
            return CreateReferenceableObject(typeof(T), args);
        }
        
        public static dynamic? CreateReferenceableObject(Type type, params object?[]? args)
        {
            if (!IsAvailable)
            {
                Init();
            }

            AssemblyLoadContext? loadContext = AssemblyLoadContext.All.FirstOrDefault(x => x.Name == "Jellyfin.Plugin.Referenceable");

            if (loadContext == null)
            {
                throw new KeyNotFoundException(@"Could not find Jellyfin.Plugin.Referenceable as an AssemblyLoadContext");
            }
            
            Type? referenceableType = loadContext.Assemblies.SelectMany(x => x.GetTypes()).FirstOrDefault(x => x.FullName == type.FullName);

            if (referenceableType == null)
            {
                return null;
            }
            
            return Activator.CreateInstance(referenceableType, args);
        }

        public static dynamic? CreateReferenceableObject<T>(IServiceProvider serviceProvider, params object[]? args)
        {
            return CreateReferenceableObject(typeof(T), serviceProvider, args);
        }
        
        public static dynamic? CreateReferenceableObject(Type type, IServiceProvider serviceProvider, params object[]? args)
        {
            if (!IsAvailable)
            {
                Init();
            }
            
            AssemblyLoadContext? loadContext = AssemblyLoadContext.All.FirstOrDefault(x => x.Name == "Jellyfin.Plugin.Referenceable");

            if (loadContext == null)
            {
                throw new KeyNotFoundException(@"Could not find Jellyfin.Plugin.Referenceable as an AssemblyLoadContext");
            }
            
            Type? referenceableType = loadContext.Assemblies.SelectMany(x => x.GetTypes()).FirstOrDefault(x => x.FullName == type.FullName);
            
            if (referenceableType == null)
            {
                return null;
            }

            if (args == null || args.Length == 0)
            {
                return ActivatorUtilities.CreateInstance(serviceProvider, referenceableType);
            }

            return ActivatorUtilities.CreateInstance(serviceProvider, referenceableType, args);
        }

        public static Type? GetReferenceableType<T>()
        {
            return AssemblyLoadContext.All
                .SelectMany(x => x.Assemblies)
                .Where(x => !x.IsCollectible)
                .SelectMany(x => x.GetTypes())
                .FirstOrDefault(x => x.FullName == typeof(T).FullName);
        }
    }
#nullable restore
}